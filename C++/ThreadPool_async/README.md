
## 简介


- 这是异步线程池的实现，和同步线程池不同的只有 `addTask` 函数的实现体不同




## 解释`addTask`

-   模板的实现必须在它们的声明可见的地方（通常在头文件中），因为编译器需要在使用模板时能够访问到它们的实现
-   使用泛型编程，应用于多种情况，`typename... Args` 这个表示可以接收任意数量类型的参数
-   返回值类型推导使用萃取器，`result_of` 模板函数来实现，`result_of<F(Args...)>::type` 表示带有 `Args...` 的 `F` 函数的类型，前面加有 `typename` 是告诉编辑器这是一个类型，不是函数
-   `addTask` 里面的类型使用 `&&` ，这个表示是一个未定义类型，可以接收左值和右值，这么定义是为了适用于多种情况，可以传右值和左值，如果不这么定义，也就是去掉 `&&`，会进行值拷贝，开销过大，如果只有一个 `&` 对于传右值情况都会转换为左值，但是使用这个形式，再结合 `forward` 完美转发，就能实现传递左值就是左值，传递右值就是右值
-   `forward` 功能就是上述解释的，实现：`forward<F>(f)` `F` 是要完美转发的变量类型，`f` 是实际要完美转发的变量
-   `package_task` 是实现得到线程返回值的，`<>` 里面填写返回值类型 `returnYype` 和参数类型 `()` ，这里参数为空，是因为可能存在参数，也可能不存在，这里不易写，那么全部搞成无参，而参数提前和可调用对象绑定起来，这里就用到了 `bind` 绑定器
-   `std::bind(可调用对象地址, 绑定的参数/占位符);` 这是 `bind` 的实现体，由于为了实现传递左值，就按左值接收，传递右值按右值接收，这里使用完美转发 `forward`
-   上面的 `task` 使用指针，是因为防止拷贝，因为最终是要得到 `future` 对象，如果传值，拷贝一份，执行的就是拷贝的副本在执行，就得不到正确的 `future` 对象了，`lambda` 传引用也不行，这个构造函数执行完毕后，当前 `task` 生命周期结束，再执行这个任务函数，就非法操作了
-   为了方便管理指针，这里使用了 `shared_ptr` 共享智能指针实现，因为会自动释放内存，安全性高，使用方法是 `<>` 里面写指针类型，在定义指针即可
-   由于加任务，这个任务队列是共享资源，因此需要使用互斥锁